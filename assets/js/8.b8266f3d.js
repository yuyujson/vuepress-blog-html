(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{526:function(v,_,l){"use strict";l.r(_);var a=l(29),i=Object(a.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[l("a",{attrs:{href:"https://segmentfault.com/a/1190000014395186?utm_source=tag-newest#articleHeader0",target:"_blank",rel:"noopener noreferrer"}},[v._v("转载自"),l("OutboundLink")],1)]),v._v(" "),l("h2",{attrs:{id:"java运行时数据区"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#java运行时数据区"}},[v._v("#")]),v._v(" Java运行时数据区")]),v._v(" "),l("blockquote",[l("p",[v._v("Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图：")])]),v._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/20210214154247.png",alt:"image.png"}})]),v._v(" "),l("ol",[l("li",[v._v("程序计数器：指向当前线程正在执行的字节码指令。线程私有的。")]),v._v(" "),l("li",[v._v("虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。")]),v._v(" "),l("li",[v._v("栈帧：栈帧存储方法的相关信息，包含局部变量数表、返回值、操作数栈、动态链接\n"),l("ol",[l("li",[v._v("局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。\n"),l("ol",[l("li",[v._v("返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。\n"),l("ol",[l("li",[v._v("操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。\n"),l("ol",[l("li",[v._v("动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。")])])])])])])])])]),v._v(" "),l("li",[v._v("线程私有")]),v._v(" "),l("li",[v._v("本地方法栈：")]),v._v(" "),l("li",[v._v("调用本地native的内存模型")]),v._v(" "),l("li",[v._v("线程独享。")]),v._v(" "),l("li",[v._v("方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据")]),v._v(" "),l("li",[v._v("线程共享的")]),v._v(" "),l("li",[v._v("运行时常量池：")])]),v._v(" "),l("blockquote",[l("p",[v._v("A、是方法区的一部分\nB、存放编译期生成的各种字面量和符号引用\nC、Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池中。")])]),v._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[v._v("堆（Heap）：Java对象存储的地方")]),v._v(" "),l("li",[v._v("Java堆是虚拟机管理的内存中最大的一块")]),v._v(" "),l("li",[v._v("Java堆是所有线程共享的区域")]),v._v(" "),l("li",[v._v("在虚拟机启动时创建")]),v._v(" "),l("li",[v._v("此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组")]),v._v(" "),l("li",[v._v("Java堆是垃圾收集器管理的内存区域，因此很多时候称为“GC堆”")])]),v._v(" "),l("hr"),v._v(" "),l("h2",{attrs:{id:"jmm-java内存模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#jmm-java内存模型"}},[v._v("#")]),v._v(" JMM Java内存模型：")]),v._v(" "),l("ol",[l("li",[v._v("Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。")]),v._v(" "),l("li",[v._v("主要目的是定义程序中各个变量的访问规则。")]),v._v(" "),l("li",[v._v("Java内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。")]),v._v(" "),l("li",[v._v("线程的工作内存中保存了被该线程使用到的变量的拷贝（从主内存中拷贝过来），线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。")]),v._v(" "),l("li",[v._v("不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递都要通过主内存来完成。")]),v._v(" "),l("li",[v._v("主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。")])]),v._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/20210214153812.png",alt:"image.png"}})]),v._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[v._v("Java线程之间的通信由内存模型JMM（Java Memory Model）控制。")])]),v._v(" "),l("ul",[l("li",[v._v("JMM决定一个线程对变量的写入何时对另一个线程可见。")]),v._v(" "),l("li",[v._v("线程之间共享变量存储在主内存中")]),v._v(" "),l("li",[v._v("每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。")]),v._v(" "),l("li",[v._v("JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。")])]),v._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[v._v("可见性、有序性：")])]),v._v(" "),l("ul",[l("li",[v._v("当一个共享变量在多个本地内存中有副本时，如果一个本地内存修改了该变量的副本，其他变量应该能够看到修改后的值，此为可见性。")]),v._v(" "),l("li",[v._v("保证线程的有序执行，这个为有序性。（保证线程安全）")])]),v._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[v._v("内存间交互操作：")]),v._v(" "),l("li",[v._v("lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。")]),v._v(" "),l("li",[v._v("unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")]),v._v(" "),l("li",[v._v("read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。")]),v._v(" "),l("li",[v._v("load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中")]),v._v(" "),l("li",[v._v("use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。")]),v._v(" "),l("li",[v._v("assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。")]),v._v(" "),l("li",[v._v("store（存储）：把工作内存的变量的值传递给主内存")]),v._v(" "),l("li",[v._v("write（写入）：把store操作的值入到主内存的变量中")])]),v._v(" "),l("p",[l("strong",[v._v("注意：")])]),v._v(" "),l("ul",[l("li",[v._v("不允许read、load、store、write操作之一单独出现")]),v._v(" "),l("li",[v._v("不允许一个线程丢弃assgin操作")]),v._v(" "),l("li",[v._v("不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中")]),v._v(" "),l("li",[v._v("一个新的变量只能在主内存中生成")]),v._v(" "),l("li",[v._v("一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁")]),v._v(" "),l("li",[v._v("如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。")]),v._v(" "),l("li",[v._v("如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量")]),v._v(" "),l("li",[v._v("对一个变量执行unlock操作之前，需要将该变量同步回主内存中")])]),v._v(" "),l("hr"),v._v(" "),l("h2",{attrs:{id:"堆的内存划分"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#堆的内存划分"}},[v._v("#")]),v._v(" 堆的内存划分：")]),v._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/20210214153833.png",alt:"image.png"}}),v._v("\nJava堆的内存划分如图所示，分别为年轻代、Old Memory（老年代）、Perm（永久代）。其中在Jdk1.8中，永久代被移除，使用MetaSpace代替。")]),v._v(" "),l("ol",[l("li",[v._v("新生代：")]),v._v(" "),l("li",[v._v("使用复制清除算法（Copinng算法），原因是年轻代每次GC都要回收大部分对象。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。")]),v._v(" "),l("li",[v._v("分为Eden、Survivor From、Survivor To，比例默认为8：1：1")]),v._v(" "),l("li",[v._v("内存不足时发生Minor GC")]),v._v(" "),l("li",[v._v("老年代：")]),v._v(" "),l("li",[v._v("采用标记-整理算法（mark-compact），原因是老年代每次GC只会回收少部分对象。")]),v._v(" "),l("li",[v._v("Perm：用来存储类的元数据，也就是方法区。")]),v._v(" "),l("li",[v._v("Perm的废除：在jdk1.8中，Perm被替换成MetaSpace，MetaSpace存放在本地内存中。原因是永久代进场内存不够用，或者发生内存泄漏。")]),v._v(" "),l("li",[v._v("MetaSpace（元空间）：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。")]),v._v(" "),l("li",[v._v("堆内存的划分在JVM里面的示意图：")])]),v._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/20210214153854.png",alt:"image.png"}})]),v._v(" "),l("hr"),v._v(" "),l("h2",{attrs:{id:"gc垃圾回收"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#gc垃圾回收"}},[v._v("#")]),v._v(" GC垃圾回收：")]),v._v(" "),l("h3",{attrs:{id:"判断对象是否要回收的方法-可达性分析法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#判断对象是否要回收的方法-可达性分析法"}},[v._v("#")]),v._v(" 判断对象是否要回收的方法：可达性分析法")]),v._v(" "),l("ol",[l("li",[v._v("通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的）")]),v._v(" "),l("li",[v._v("以下对象会被认为是root对象：")]),v._v(" "),l("li",[v._v("虚拟机栈（栈帧中本地变量表）中引用的对象")]),v._v(" "),l("li",[v._v("方法区中静态属性引用的对象")]),v._v(" "),l("li",[v._v("方法区中常量引用的对象")]),v._v(" "),l("li",[v._v("本地方法栈中Native方法引用的对象")]),v._v(" "),l("li",[v._v("对象被判定可被回收，需要经历两个阶段：")]),v._v(" "),l("li",[v._v("第一个阶段是可达性分析，分析该对象是否可达")]),v._v(" "),l("li",[v._v("第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会）")]),v._v(" "),l("li",[v._v("方法区中的垃圾回收：")]),v._v(" "),l("li",[v._v("常量池中一些常量、符号引用没有被引用，则会被清理出常量池")]),v._v(" "),l("li",[v._v("无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：")])]),v._v(" "),l("ul",[l("li",[v._v("该类的所有实例被回收")]),v._v(" "),l("li",[v._v("加载该类的ClassLoader被回收")]),v._v(" "),l("li",[v._v("该类的Class对象没有被引用")])]),v._v(" "),l("ol",{attrs:{start:"7"}},[l("li",[v._v("finalize():")])]),v._v(" "),l("ul",[l("li",[v._v("GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。")]),v._v(" "),l("li",[v._v("可以在该方法里面，指定一些对象在释放前必须执行的操作。")])]),v._v(" "),l("h3",{attrs:{id:"发现虚拟机频繁full-gc时应该怎么办"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#发现虚拟机频繁full-gc时应该怎么办"}},[v._v("#")]),v._v(" 发现虚拟机频繁full GC时应该怎么办：")]),v._v(" "),l("p",[v._v("（full GC指的是清理整个堆空间，包括年轻代和永久代）")]),v._v(" "),l("ul",[l("li",[v._v("首先用命令查看触发GC的原因是什么 jstat –gccause 进程id")]),v._v(" "),l("li",[v._v("如果是System.gc()，则看下代码哪里调用了这个方法")]),v._v(" "),l("li",[v._v("如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令")]),v._v(" "),l("li",[v._v("如果是GC locker，可能是程序依赖的JNI库的原因")])]),v._v(" "),l("h3",{attrs:{id:"常见的垃圾回收算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见的垃圾回收算法"}},[v._v("#")]),v._v(" 常见的垃圾回收算法：")]),v._v(" "),l("ol",[l("li",[v._v("Mark-Sweep（标记-清除算法）：")])]),v._v(" "),l("ul",[l("li",[v._v("思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。")]),v._v(" "),l("li",[v._v("优缺点：实现简单，容易产生内存碎片")])]),v._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[v._v("Copying（复制清除算法）：")])]),v._v(" "),l("ul",[l("li",[v._v("思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。")]),v._v(" "),l("li",[v._v("优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。")])]),v._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[v._v("Mark-Compact（标记-整理算法）：")])]),v._v(" "),l("ul",[l("li",[v._v("思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。")]),v._v(" "),l("li",[v._v("优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下")])]),v._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[v._v("分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：")])]),v._v(" "),l("blockquote",[l("p",[v._v("思想：把堆分成新生代和老年代。（永久代指的是方法区）")])]),v._v(" "),l("ol",[l("li",[v._v("因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。")]),v._v(" "),l("li",[v._v("由于老年代每次只回收少量的对象，因此采用mark-compact算法。")]),v._v(" "),l("li",[v._v("在堆区外有一个永久代。对永久代的回收主要是无效的类和常量")]),v._v(" "),l("li",[v._v("GC使用时对程序的影响？")])]),v._v(" "),l("p",[v._v("垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间")]),v._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[v._v("几种不同的垃圾回收类型：")])]),v._v(" "),l("ul",[l("li",[v._v("Minor GC：从年轻代（包括Eden、Survivor区）回收内存。")])]),v._v(" "),l("blockquote",[l("p",[v._v("A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC\nB、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。")])]),v._v(" "),l("ul",[l("li",[v._v("Major GC：清理整个老年代，当eden区内存不足时触发。")]),v._v(" "),l("li",[v._v("Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发")])])])}),[],!1,null,null,null);_.default=i.exports}}]);