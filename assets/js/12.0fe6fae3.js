(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{530:function(n,s,a){"use strict";a.r(s);var e=a(29),t=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[n._v("#")]),n._v(" 简介")]),n._v(" "),a("blockquote",[a("p",[n._v("AQS 全拼为 "),a("code",[n._v("AbstractQueuedSynchronizer")]),n._v(" , 即"),a("strong",[n._v("队列同步器")]),n._v(". 它是构建锁或者其他同步组件的基础框架(如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等). 它是 J.U.C 并发包中的核心基础组件。\n"),a("code",[n._v("JAVA API")]),n._v(" 描述如下: 提供一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。 该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。")])]),n._v(" "),a("p",[n._v("我们简单理解如下:")]),n._v(" "),a("ol",[a("li",[a("p",[n._v("AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作：")]),n._v(" "),a("ul",[a("li",[n._v("如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程")]),n._v(" "),a("li",[n._v("当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。")])])]),n._v(" "),a("li",[a("p",[n._v("AQS 的主要使用方式是继承，子类通过继承AQS同步器，并实现它的抽象方法来管理同步状态。")])]),n._v(" "),a("li",[a("p",[n._v("AQS 使用一个 int 类型的成员变量 "),a("code",[n._v("state")]),n._v(" 来表示同步状态：")]),n._v(" "),a("ul",[a("li",[n._v("当 "),a("code",[n._v("state > 0")]),n._v(" 时，表示已经获取了锁。")]),n._v(" "),a("li",[n._v("当 "),a("code",[n._v("state = 0")]),n._v(" 时，表示释放了锁。")])])]),n._v(" "),a("li",[a("p",[n._v("它提供了三个方法，来对同步状态 "),a("code",[n._v("state")]),n._v(" 进行操作，并且 AQS 可以确保对 "),a("code",[n._v("state")]),n._v(" 的操作是安全的：")]),n._v(" "),a("ul",[a("li",[n._v("getState()")]),n._v(" "),a("li",[n._v("setState(int newState)")]),n._v(" "),a("li",[n._v("compareAndSetState(int expect, int update)")])])])]),n._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/20210207204952.png",alt:""}})]),n._v(" "),a("hr"),n._v(" "),a("h2",{attrs:{id:"clh-同步列队"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clh-同步列队"}},[n._v("#")]),n._v(" CLH 同步列队")]),n._v(" "),a("h3",{attrs:{id:"abstractqueuedsynchronizer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstractqueuedsynchronizer"}},[n._v("#")]),n._v(" AbstractQueuedSynchronizer")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {\n    protected AbstractQueuedSynchronizer() { }\n    // Node头节点\n    private transient volatile Node head;\n\n    // Node尾节点\n    private transient volatile Node tail;\n\n    // 同步状态 当 state > 0 时，表示已经获取了锁; 当 state = 0 时，表示释放了锁。\n    private volatile int state;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br")])]),a("p",[n._v("注意此处"),a("code",[n._v("AbstractQueuedSynchronizer")]),n._v("抽象类的只有一个无参构造, 没有对任何常量进行赋值")]),n._v(" "),a("h3",{attrs:{id:"内部静态类-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部静态类-node"}},[n._v("#")]),n._v(" 内部静态类 Node")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("static final class Node {\n\n    // 共享\n    static final Node SHARED = new Node();\n    // 独占\n    static final Node EXCLUSIVE = null;\n    /**\n     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态\n     */\n    static final int CANCELLED =  1;\n    /**\n     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行\n     */\n    static final int SIGNAL    = -1;\n    /**\n     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中\n     */\n    static final int CONDITION = -2;\n    /**\n     * 表示下一次共享式同步状态获取，将会无条件地传播下去\n     */\n    static final int PROPAGATE = -3;\n\n    /** 等待状态 */\n    volatile int waitStatus;\n\n    /** 前驱节点，当节点添加到同步队列时被设置（尾部添加） */\n    volatile Node prev;\n\n    /** 后继节点 */\n    volatile Node next;\n\n    /** 等待队列中的后续节点。如果当前节点是共享的，那么字段将是一个 SHARED 常量，也就是说节点类型（独占和共享）和等待队列中的后续节点共用同一个字段 */\n    Node nextWaiter;\n    \n    /** 获取同步状态的线程 */\n    volatile Thread thread;\n\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n    Node() {    // Used to establish initial head or SHARED marker\n    }\n\n    Node(Thread thread, Node mode) {     // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br"),a("span",{staticClass:"line-number"},[n._v("46")]),a("br"),a("span",{staticClass:"line-number"},[n._v("47")]),a("br"),a("span",{staticClass:"line-number"},[n._v("48")]),a("br"),a("span",{staticClass:"line-number"},[n._v("49")]),a("br"),a("span",{staticClass:"line-number"},[n._v("50")]),a("br"),a("span",{staticClass:"line-number"},[n._v("51")]),a("br"),a("span",{staticClass:"line-number"},[n._v("52")]),a("br"),a("span",{staticClass:"line-number"},[n._v("53")]),a("br"),a("span",{staticClass:"line-number"},[n._v("54")]),a("br")])]),a("h3",{attrs:{id:"整体模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#整体模型"}},[n._v("#")]),n._v(" 整体模型")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yuyujson/cdn-images@latest/blog-images/20210207205022.png",alt:""}})]),n._v(" "),a("p",[a("strong",[n._v("注意:")])]),n._v(" "),a("blockquote",[a("p",[n._v("Node 是链表结构, 此处的多个 Node 是存放在 "),a("code",[n._v("AbstractQueuedSynchronizer")]),n._v(" 类的 "),a("code",[n._v("private transient volatile Node head")]),n._v(" 中")]),n._v(" "),a("ol",[a("li",[a("code",[n._v("Node链表 = head.next")])]),n._v(" "),a("li",[a("strong",[a("code",[n._v("head")]),n._v(" 节点存放的是当前获取锁的线程, 对应的thread为空, 可以理解为第一个人正在办理,从第二个人开始才算排队")])]),n._v(" "),a("li",[a("code",[n._v("tail = Node链表最后一个 = head最后一个元素")])])])]),n._v(" "),a("h3",{attrs:{id:"源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[n._v("#")]),n._v(" 源码")]),n._v(" "),a("p",[n._v("简单想一下, 大致流程应该分为三步")]),n._v(" "),a("ol",[a("li",[n._v("tail 指向新节点")]),n._v(" "),a("li",[n._v("新节点的 pre 指向老节点")]),n._v(" "),a("li",[n._v("老节点的 next 指向新节点")])]),n._v(" "),a("p",[n._v("再考虑到并发情况, 使用类似 synchronized 之类的给这段代码加锁")]),n._v(" "),a("h4",{attrs:{id:"入列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#入列"}},[n._v("#")]),n._v(" 入列")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("private Node addWaiter(Node mode) {\n    // 新建节点 this.nextWaiter = mode; this.thread = thread;\n    Node node = new Node(Thread.currentThread(), mode);\n    // 记录原尾节点\n    Node pred = tail;\n    // 快速尝试，添加新节点为尾节点\n    if (pred != null) {\n        // 设置新 Node 节点的尾节点为原尾节点\n        node.prev = pred;\n        // CAS 设置新的尾节点\n        if (compareAndSetTail(pred, node)) {\n            // 成功，原尾节点的下一个节点为新节点\n            pred.next = node;\n            return node;\n        }\n    }\n    // 失败，多次尝试，直到成功\n    enq(node);\n    return node;\n}\n\nprivate Node enq(final Node node) {\n    // 多次尝试，直到成功为止\n    for (;;) {\n        // 记录原尾节点\n        Node t = tail;\n        // 原尾节点不存在，创建首尾节点都为 new Node()\n        if (t == null) {\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        // 原尾节点存在，添加新节点为尾节点\n        } else {\n            //设置为尾节点\n            node.prev = t;\n            // CAS 设置新的尾节点\n            if (compareAndSetTail(t, node)) {\n                // 成功，原尾节点的下一个节点为新节点\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br")])]),a("p",[n._v("注意 :")]),n._v(" "),a("blockquote",[a("ol",[a("li",[n._v("在调用 "),a("code",[n._v("#enq(final Node node)")]),n._v(" 方法时, 如果tail为null, 创建的是一个新的Node节点, 并且这个Node节点里面的字段值都没有初始化")]),n._v(" "),a("li",[n._v("然后进行第二次循环, 这时 tail 已经不为Null, 再进行赋值")])])]),n._v(" "),a("p",[n._v("不太明白为什么要有快速尝试那一步,  "),a("code",[n._v("#enq(final Node node)")]),n._v(" 方法的代码有着同样的功能, 可能是为了代码的可读性吧.")]),n._v(" "),a("h4",{attrs:{id:"出列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#出列"}},[n._v("#")]),n._v(" 出列")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("private void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])]),a("p",[n._v("这个方法比较简单, 此处为单线程操作,不需加锁")]),n._v(" "),a("hr"),n._v(" "),a("h2",{attrs:{id:"同步状态的获取与释放"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步状态的获取与释放"}},[n._v("#")]),n._v(" 同步状态的获取与释放")]),n._v(" "),a("p",[n._v("AQS 的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态。对于子类而言，它并没有太多的活要做，AQS 已经提供了大量的模板方法来实现同步，主要是分为三类：")]),n._v(" "),a("ul",[a("li",[n._v("独占式获取和释放同步状态")]),n._v(" "),a("li",[n._v("共享式获取和释放同步状态")]),n._v(" "),a("li",[n._v("查询同步队列中的等待线程情况。")])]),n._v(" "),a("h3",{attrs:{id:"类内部方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类内部方法"}},[n._v("#")]),n._v(" 类内部方法")]),n._v(" "),a("p",[n._v("AQS 主要提供了如下方法：")]),n._v(" "),a("ul",[a("li",[a("p",[a("code",[n._v("#getState()")]),n._v("：返回同步状态的当前值。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#setState(int newState)")]),n._v("：设置当前同步状态。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#compareAndSetState(int expect, int update)")]),n._v("：使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。")])]),n._v(" "),a("li",[a("p",[n._v("【可重写】"),a("code",[n._v("#tryAcquire(int arg)")]),n._v("：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态。")])]),n._v(" "),a("li",[a("p",[n._v("【可重写】"),a("code",[n._v("#tryRelease(int arg)")]),n._v("：独占式释放同步状态。")])]),n._v(" "),a("li",[a("p",[n._v("【可重写】"),a("code",[n._v("#tryAcquireShared(int arg)")]),n._v("：共享式获取同步状态，返回值大于等于 0 ，则表示获取成功；否则，获取失败。")])]),n._v(" "),a("li",[a("p",[n._v("【可重写】"),a("code",[n._v("#tryReleaseShared(int arg)")]),n._v("：共享式释放同步状态。")])]),n._v(" "),a("li",[a("p",[n._v("【可重写】"),a("code",[n._v("#isHeldExclusively()")]),n._v("：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("acquire(int arg)")]),n._v("：独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待。该方法将会调用可重写的 "),a("code",[n._v("#tryAcquire(int arg)")]),n._v(" 方法；")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#acquireInterruptibly(int arg)")]),n._v("：与 "),a("code",[n._v("#acquire(int arg)")]),n._v(" 相同，但是该方法响应中断。当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 异常并返回。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#tryAcquireNanos(int arg, long nanos)")]),n._v("：超时获取同步状态。如果当前线程在 nanos 时间内没有获取到同步状态，那么将会返回 false ，已经获取则返回 true 。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#acquireShared(int arg)")]),n._v("：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#acquireSharedInterruptibly(int arg)")]),n._v("：共享式获取同步状态，响应中断。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#tryAcquireSharedNanos(int arg, long nanosTimeout)")]),n._v("：共享式获取同步状态，增加超时限制。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#release(int arg)")]),n._v("：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。")])]),n._v(" "),a("li",[a("p",[a("code",[n._v("#releaseShared(int arg)")]),n._v("：共享式释放同步状态。")])])]),n._v(" "),a("p",[n._v("从上面的方法看下来，基本上可以分成 3 类：")]),n._v(" "),a("ul",[a("li",[n._v("独占式获取与释放同步状态")]),n._v(" "),a("li",[n._v("共享式获取与释放同步状态")]),n._v(" "),a("li",[n._v("查询同步队列中的等待线程情况")])]),n._v(" "),a("h3",{attrs:{id:"独占式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占式"}},[n._v("#")]),n._v(" 独占式")]),n._v(" "),a("p",[n._v("同一时刻，仅有一个线程持有同步状态。")]),n._v(" "),a("h4",{attrs:{id:"独占式同步状态获取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占式同步状态获取"}},[n._v("#")]),n._v(" 独占式同步状态获取")]),n._v(" "),a("blockquote",[a("p",[a("code",[n._v("#acquire(int arg)")]),n._v(" 方法，为 AQS 提供的模板方法。该方法为独占式获取同步状态，但是该方法对中断不敏感。也就是说，由于线程获取同步状态失败而加入到 CLH 同步队列中，后续对该线程进行中断操作时，线程不会从 CLH 同步队列中移除。代码如下：")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])]),a("p",[n._v("可以拆分成下面这样看")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("public final void acquire(int arg) {\n    // 首先尝试获取独占锁 (该方法需要自己实现), 尝试失败后执行下方代码\n    if(!tryAcquire(arg)){\n        // static final Node EXCLUSIVE = null;\n        // 上方讲到的入列的动作\n        Node node = addWaiter(Node.EXCLUSIVE);\n        // 自旋直到获得同步状态成功 \n        // 当返回 true 时，表示在这个过程中，发生过线程中断\n        boolean flag = acquireQueued(node, arg);\n        if(flag){\n            // 恢复线程中断的标识\n            selfInterrupt();\n        }\n    }\n}\n\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br")])]),a("h5",{attrs:{id:"acquirequeued"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acquirequeued"}},[n._v("#")]),n._v(" acquireQueued")]),n._v(" "),a("p",[n._v("该方法为一个自旋的过程，也就是说，当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。\n"),a("img",{attrs:{src:"acquireQueued.png",alt:"流程图"}})]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("final boolean acquireQueued(final Node node, int arg) {\n    // 记录是否获取同步状态成功\n    boolean failed = true;\n    try {\n        // 记录过程中，是否发生线程中断\n        boolean interrupted = false;\n        /*\n         * 自旋过程，其实就是一个死循环而已\n         */\n        for (;;) {\n            // 当前线程的前驱节点\n            final Node p = node.predecessor();\n            // 前驱节点是头结点\n            if (p == head) {\n                // 尝试获取独占锁\n                if(tryAcquire(arg)){\n                    // 设置当前节点( 线程 )为新的 head\n                    setHead(node);\n                    // 设置老的头节点 p 不再指向下一个节点，让它自身更快的被 GC 。\n                    p.next = null;\n                    // 标记 failed = false ，表示获取同步状态成功\n                    failed = false;\n                    // 返回记录获取过程中，是否发生线程中断。\n                    return interrupted;\n                }\n            }\n            // 判断获取失败后，是否当前线程需要阻塞等待。\n            if (shouldParkAfterFailedAcquire(p, node)){\n               // 线程等待, 调用的是 LockSupport.park(this); 这个方法会让出CPU\n                if(parkAndCheckInterrupt()){\n                    interrupted = true;\n                }\n            }\n        }\n    } finally {\n        // 获取同步状态发生异常，取消获取。（一般用不到， 可忽略）\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\nclass Thread{\n    public static boolean interrupted() {\n        return currentThread().isInterrupted(true);\n    }\n}\n\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br"),a("span",{staticClass:"line-number"},[n._v("46")]),a("br"),a("span",{staticClass:"line-number"},[n._v("47")]),a("br"),a("span",{staticClass:"line-number"},[n._v("48")]),a("br"),a("span",{staticClass:"line-number"},[n._v("49")]),a("br"),a("span",{staticClass:"line-number"},[n._v("50")]),a("br"),a("span",{staticClass:"line-number"},[n._v("51")]),a("br")])]),a("h5",{attrs:{id:"shouldparkafterfailedacquire-是否需要park"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldparkafterfailedacquire-是否需要park"}},[n._v("#")]),n._v(" shouldParkAfterFailedAcquire （是否需要park）")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("/**\n * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态 (一般用不到，忽略)\n */\nstatic final int CANCELLED =  1;\n/**\n * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行\n * 默认值为 0，第二次循环会变为-1，如果为-1 ，当前线程park。 可以使用status ！= 0 来判断是否是尾节点，（如果是尾结点，status = 0）\n */\nstatic final int SIGNAL    = -1;\n/**\n * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中\n */\nstatic final int CONDITION = -2;\n/**\n * 表示下一次共享式同步状态获取，将会无条件地传播下去\n */\nstatic final int PROPAGATE = -3;\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    // 获得前一个节点的等待状态\n    int ws = pred.waitStatus;\n    // 等待状态为 Node.SIGNAL 时，表示 pred 的下一个节点 node 的线程需要阻塞等待。在 pred 的线程释放同步状态时，会对 node 的线程进行唤醒通知。\n    // 返回 true ，表明当前线程可以被 park，安全的阻塞等待。\n    if (ws == Node.SIGNAL) \n        return true;\n    if (ws > 0) {\n        // 等待状态为 NODE.CANCELLED 时，则表明该线程的前一个节点已经等待超时或者被中断了，则需要从 CLH 队列中将该前一个节点删除掉，循环回溯，直到前一个节点状态 <= 0 \n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        // 等待状态为 0 或者 Node.PROPAGATE 时，通过 CAS 设置，将状态修改为 Node.SIGNAL\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br")])]),a("h5",{attrs:{id:"cancelacquire-一般用不到-可忽略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cancelacquire-一般用不到-可忽略"}},[n._v("#")]),n._v(" cancelAcquire（一般用不到， 可忽略）")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("private void cancelAcquire(Node node) {\n    // 将节点的线程置空\n    node.thread = null;\n\n    // 前置节点\n    Node pred = node.prev;\n    // 前置节点超时或等待, 删除前置节点\n    while (pred.waitStatus > 0){\n        node.prev = pred = pred.prev;\n    }\n    // 由于存在并发情况, 我们需要将 pred.next 暂存起来\n    Node predNext = pred.next;\n    \n    // 设置 node 节点的为取消的等待状态 Node.CANCELLED\n    // 这里可以使用直接写，而不是 CAS\n    // 在这个操作之后，其它 Node 节点可以忽略 node\n    node.waitStatus = Node.CANCELLED;\n\n    // 如果node为尾结点 并且--cas设置this的尾结点为缓存的前置节点, 期望值为node-- 成功\n    if (node == tail && compareAndSetTail(node, pred)) {\n        // cas设置缓存的前置节点的后置节点为 null, 期望值为predNext\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred's next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        // 前置节点不为头结点\n        // 并且 (前置节点的等待状态为 Node.SIGNAL 或者 (前置节点的等待状态 <0 并且 尝试将前置节点的等待状态修改为 Node.SIGNAL 成功 并且 前置节点的线程不为null)\n        if (pred != head && \n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n            pred.thread != null) {\n            Node next = node.next;\n            if (next != null && next.waitStatus <= 0)\n                // CAS 设置 pred 的下一个节点为 next\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            // 唤醒 node 的下一个节点的线程等待\n            unparkSuccessor(node);\n        }\n\n        node.next = node; // help GC\n    }\n}\nprivate final boolean compareAndSetTail(Node expect, Node update) {\n    // 变更 this的尾结点 为 update ,期望变更为 expect\n    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);\n}\nprivate static final boolean compareAndSetNext(Node node, Node expect, Node update) {\n    // 变更 node 的后置节点 为 update ,期望变更为 expect\n    return unsafe.compareAndSwapObject(node, nextOffset, expect, update);\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br"),a("span",{staticClass:"line-number"},[n._v("36")]),a("br"),a("span",{staticClass:"line-number"},[n._v("37")]),a("br"),a("span",{staticClass:"line-number"},[n._v("38")]),a("br"),a("span",{staticClass:"line-number"},[n._v("39")]),a("br"),a("span",{staticClass:"line-number"},[n._v("40")]),a("br"),a("span",{staticClass:"line-number"},[n._v("41")]),a("br"),a("span",{staticClass:"line-number"},[n._v("42")]),a("br"),a("span",{staticClass:"line-number"},[n._v("43")]),a("br"),a("span",{staticClass:"line-number"},[n._v("44")]),a("br"),a("span",{staticClass:"line-number"},[n._v("45")]),a("br"),a("span",{staticClass:"line-number"},[n._v("46")]),a("br"),a("span",{staticClass:"line-number"},[n._v("47")]),a("br"),a("span",{staticClass:"line-number"},[n._v("48")]),a("br"),a("span",{staticClass:"line-number"},[n._v("49")]),a("br"),a("span",{staticClass:"line-number"},[n._v("50")]),a("br"),a("span",{staticClass:"line-number"},[n._v("51")]),a("br"),a("span",{staticClass:"line-number"},[n._v("52")]),a("br")])]),a("h4",{attrs:{id:"独占式获取响应中断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占式获取响应中断"}},[n._v("#")]),n._v(" 独占式获取响应中断")]),n._v(" "),a("p",[n._v("AQS 提供了"),a("code",[n._v("acquire(int arg)")]),n._v(" 方法，以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中，等待着获取同步状态。为了响应中断，AQS 提供了"),a("code",[n._v("#acquireInterruptibly(int arg)")]),n._v(" 方法。该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断，并抛出 "),a("code",[n._v("InterruptedException")]),n._v(" 异常。")]),n._v(" "),a("p",[a("strong",[n._v("大部分摘抄自")]),n._v(":")]),n._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"http://www.iocoder.cn/categories/JUC/?vip",target:"_blank",rel:"noopener noreferrer"}},[n._v("芋道源码"),a("OutboundLink")],1)]),n._v(" "),a("li",[a("a",{attrs:{href:"http://cmsblogs.com/?p=2197",target:"_blank",rel:"noopener noreferrer"}},[n._v("小明哥"),a("OutboundLink")],1)]),n._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/java_lyvee/article/details/98966684",target:"_blank",rel:"noopener noreferrer"}},[n._v("JUC AQS ReentrantLock源码分析"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=t.exports}}]);